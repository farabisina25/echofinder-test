import { fetchEmbedding } from '../services/embedding.js';
import { upsertIssue, findNearest } from '../db.js';

const SIMILARITY_THRESHOLD = 0.70;

export async function handleIssueOpened(context) {
    const issue = context.payload.issue;
    const owner = context.payload.repository.owner.login;
    const repo = context.payload.repository.name;
    const repoName = `${owner}/${repo}`;

    console.log(`\n${'='.repeat(50)}`);
    console.log(`üìã NEW ISSUE DETECTED`);
    console.log(`Repository: ${repoName}`);
    console.log(`Issue #${issue.number}: ${issue.title}`);
    console.log(`${'='.repeat(50)}\n`);

    try {
        // 1. Generate text and embedding for the NEW issue
        const newText = `${issue.title}\n${issue.body || ''}`;
        console.log('üîó Fetching embedding for new issue...');
        const newEmbedding = await fetchEmbedding(newText);

        if (!newEmbedding || !Array.isArray(newEmbedding)) {
            console.log('‚ö†Ô∏è Failed to generate embedding. Skipping.');
            return;
        }

        // 2. Upsert the new issue to the DB immediately
        try {
            await upsertIssue({
                id: issue.id,
                repo_name: repoName,
                issue_number: issue.number,
                title: issue.title,
                body: issue.body || '',
                author: issue.user?.login || '',
                embedding: newEmbedding,
                pairing_token: null,
                merge_state: 'none'
            });
            console.log('‚úÖ Issue upserted to DB');
        } catch (dbErr) {
            console.error('‚ùå DB upsert error:', dbErr.message);
            // We continue even if upsert fails, though duplication check might be limited
        }

        // 3. Search DB for nearest nieghbors (searches all repos of same owner)
        console.log(`üîç Searching database for similar issues (Owner: ${owner})...`);
        const matches = await findNearest(newEmbedding, owner, 5);

        // Filter out the issue itself
        // Use repo_name and issue_number combination for robust filtering
        const candidates = matches.filter(m =>
            !(m.repo_name === repoName && m.issue_number === issue.number)
        );

        console.log(`‚úì Found ${candidates.length} potential candidates in DB`);

        if (candidates.length === 0) {
            console.log('‚ÑπÔ∏è No similar issues found.');
            return;
        }

        // 4. Check the best match
        const bestMatch = candidates[0];
        const bestScore = bestMatch.similarity; // findNearest returns 'similarity' column

        console.log(`\nüéØ RESULTS:`);
        console.log(`Best match: ${bestMatch.repo_name}#${bestMatch.issue_number}`);
        console.log(`Title: "${bestMatch.title}"`);
        console.log(`Score: ${(bestScore * 100).toFixed(1)}%`);
        console.log(`Threshold: ${(SIMILARITY_THRESHOLD * 100).toFixed(1)}%`);

        if (bestScore > SIMILARITY_THRESHOLD) {
            console.log(`\n‚úÖ SCORE ABOVE THRESHOLD - Posting comment...\n`);

            // create a hidden pairing token with REPO info
            // format: orig=owner/repo#123;new=owner/repo#456
            const pairToken = `<!-- ECHOFINDER_PAIR:orig=${bestMatch.repo_name}#${bestMatch.issue_number};new=${repoName}#${issue.number} -->`;

            // 5. Generate Instant Preview using Gemini 2.5 Flash
            let previewContent = "";
            try {
                if (process.env.GEMINI_API_KEY) {
                    const { GoogleGenerativeAI } = await import("@google/generative-ai");
                    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
                    const modelName = process.env.GEMINI_MODEL || "gemini-2.5-flash";
                    const model = genAI.getGenerativeModel({ model: modelName });

                    const prompt = `Merge these two GitHub issues into one comprehensive issue.

ISSUE 1 (Original #${bestMatch.issue_number}):
Title: ${bestMatch.title}
Body: ${bestMatch.body || ''}

ISSUE 2 (New #${issue.number}):
Title: ${issue.title}
Body: ${issue.body || ''}

OUTPUT FORMAT:
Return a JSON object with keys "title" and "body".
Do NOT use markdown code blocks for the JSON output. Just raw JSON.`;

                    console.log('ü§ñ Generating merge preview with Gemini...');
                    const result = await model.generateContent(prompt);
                    const text = result.response.text().replace(/^```json/, '').replace(/```$/, '').trim();
                    const mergedData = JSON.parse(text);

                    previewContent = `\n\n<details>\n<summary>‚ú® <strong>Click to see Proposed Merged Issue</strong></summary>\n\n` +
                        `### ${mergedData.title}\n\n${mergedData.body}\n\n` +
                        `*(Generated by EchoFinder AI)*\n</details>`;

                    // Allow reuse of this generated content
                    const jsonPayload = Buffer.from(JSON.stringify(mergedData)).toString('base64');
                    previewContent += `\n<!-- ECHOFINDER_PREVIEW_JSON:${jsonPayload} -->`;
                }
            } catch (err) {
                console.error('‚ö†Ô∏è Gemini preview generation failed:', err.message);
                // Continue without preview
            }

            const newIssueComment = `üîç **Potential Duplicate Found**\n\n` +
                `This issue is very similar to **${bestMatch.repo_name}#${bestMatch.issue_number}**: "${bestMatch.title}"\n\n` +
                `üìä **Similarity Score:** ${(bestScore * 100).toFixed(1)}%\n` +
                previewContent + `\n\n` +
                `Please review if this is a duplicate. If confirmed, you can close this issue.\n\n` +
                `To merge these issues, BOTH issue authors must comment on *their own issue* with \`/merge\` (accept) or \`/reject\` (decline). Once both confirmations are present the bot will post a mock-merge notification.` +
                `\n\n` + pairToken;

            // Post to the NEW issue
            await context.octokit.issues.createComment({
                owner,
                repo,
                issue_number: issue.number,
                body: newIssueComment
            });

            // Also post the pairing comment to the ORIGINAL issue so confirmations there are detected
            // Use repoName (which is new issue's repo) for clarity
            const originalIssueNotice = `üîî Note: A new issue (${repoName}#${issue.number}) was opened that appears to be a possible duplicate of this issue.\n\n` +
                `**New issue title:** "${issue.title}"\n` +
                `üìä **Similarity:** ${(bestScore * 100).toFixed(1)}%\n` +
                previewContent + `\n\n` +
                `To merge these issues, BOTH issue authors must comment on *their own issue* with \`/merge\` (accept) or \`/reject\` (decline). Once both confirmations are present the bot will post a mock-merge notification.` +
                `\n\n` + pairToken;

            // Extract owner/repo
            const [origOwner, origRepo] = bestMatch.repo_name.split('/');
            await context.octokit.issues.createComment({
                owner: origOwner,
                repo: origRepo,
                issue_number: bestMatch.issue_number,
                body: originalIssueNotice
            });

            console.log('‚úÖ Comments posted to both issues');

            // Add label to NEW issue
            try {
                await context.octokit.issues.addLabels({
                    owner, repo, issue_number: issue.number, labels: ['duplicate?']
                });
            } catch (ignore) { }

            // Add label to ORIGINAL issue
            try {
                const [origOwner, origRepo] = bestMatch.repo_name.split('/');
                await context.octokit.issues.addLabels({
                    owner: origOwner, repo: origRepo, issue_number: bestMatch.issue_number, labels: ['has-duplicates']
                });
            } catch (ignore) { }

        } else {
            console.log(`\n‚è≠Ô∏è Score below threshold. No comment posted.`);
        }
        console.log(`\n${'='.repeat(50)}\n`);

    } catch (error) {
        console.error('‚ùå ERROR processing issue:', error.message);
        console.error(error);
    }
}
